---
description: Konsolidierte Regeln für VAPI-Homemade Projekt - Trae AI Optimiert
globs: **/*
alwaysApply: true
---

# 🎯 TRAE AI RULES - VAPI-HOMEMADE PROJECT
## Konsolidierte Regeln für Voice Agent Platform Development

**Version:** 3.0 (Konsolidiert aus cline_rules.md, cursor_rules.mdc, roo_rules.md)  
**Ziel:** VAPI/Retell/Artisan/Parloa überholen mit 10x besserer Performance  
**Workflow:** Taskmaster-basiert mit "weiter so" Automation  

---

## 🚀 **PROJEKT-VISION & ZIELE**

### **HAUPTZIEL**
```
🎯 VAPI-Homemade soll VAPI, Retell, Artisan.co und Parloa überholen
🎯 10x bessere Performance bei 90% niedrigeren Kosten
🎯 Ultra-Low-Latency (<100ms) Voice Agent Platform
🎯 Enterprise-Grade Features mit Open-Source Flexibilität
```

### **TECHNISCHE ZIELE**
- **WebRTC Streaming:** Echte Real-time Audio Processing
- **Whisper Integration:** Lokale STT mit Hardware-Acceleration
- **Ultra-Low-Latency:** <100ms End-to-End Response Time
- **Enterprise Features:** SIP, Multi-tenant, Analytics
- **Production Ready:** Docker, Monitoring, Scaling

---

## 📋 **TASKMASTER WORKFLOW REGELN**

### **WORKFLOW PRINZIP**
```
1. MASTERPLAN ERSTELLEN: Vollständiges PRD → parse-prd → Task-Hierarchie
2. NEXT TASK ABFRAGEN: "Was ist die nächste Task?"
3. TASK BEARBEITEN: Code implementieren, testen, dokumentieren
4. STATUS UPDATE: "Task X completed" → Automatisch nächste Task
5. BESTÄTIGUNG: "Okay, hey, ist gut, weiter so" → Workflow continues
```

### **TASKMASTER COMMANDS**
```bash
# Daily Workflow
task-master next                    # Nächste Task anzeigen
task-master show [id]              # Task Details anzeigen
task-master update-task [id]       # Task Status aktualisieren
task-master add-subtask [id]       # Subtask hinzufügen

# Planning & Analysis
task-master list --status pending  # Offene Tasks anzeigen
task-master analyze-complexity     # Komplexität bewerten
task-master expand-task [id]       # Task in Subtasks aufteilen
```

---

## 🏗️ **CODE DEVELOPMENT REGELN**

### **ARCHITEKTUR PRINZIPIEN**
```python
# 1. MICROSERVICES ARCHITECTURE
# Jeder Service hat klare Verantwortlichkeit:
# - websocket_service.py: WebRTC & Real-time Communication
# - audio_service.py: STT/TTS Processing
# - llm_service.py: AI Response Generation
# - ultra_low_latency_service.py: Performance Optimization

# 2. DEPENDENCY INJECTION
# Alle Services über FastAPI Dependency System
# Testbar, mockbar, austauschbar

# 3. ASYNC/AWAIT EVERYWHERE
# Alle I/O Operations asynchron
# WebSocket, HTTP, Database, AI APIs
```

### **PERFORMANCE REGELN**
```python
# ULTRA-LOW-LATENCY REQUIREMENTS
# - WebSocket Response: <50ms
# - STT Processing: <100ms
# - LLM Response: <200ms
# - TTS Generation: <150ms
# - Total End-to-End: <500ms

# OPTIMIZATION STRATEGIES
# 1. Connection Pooling für alle External APIs
# 2. Caching für häufige Requests
# 3. Streaming für Audio Processing
# 4. Hardware Acceleration wo möglich
```

### **CODE QUALITY STANDARDS**
```python
# 1. TYPE HINTS ÜBERALL
from typing import Dict, List, Optional, Union

def process_audio(audio_data: bytes, config: Dict[str, Any]) -> AudioResponse:
    """Process audio with type safety"""
    pass

# 2. ERROR HANDLING
try:
    result = await external_api_call()
except APIException as e:
    logger.error(f"API call failed: {e}")
    raise ServiceException(f"Processing failed: {e}")

# 3. LOGGING & MONITORING
import structlog
logger = structlog.get_logger()

@router.post("/webhook")
async def webhook_handler(request: WebhookRequest):
    logger.info("webhook_received", request_id=request.id)
    # Process...
    logger.info("webhook_processed", duration_ms=duration)
```

---

## 🐳 **DOCKER & DEPLOYMENT REGELN**

### **PRODUCTION SETUP**
```dockerfile
# MULTI-STAGE BUILDS für Optimization
FROM python:3.11-slim as base
# Dependencies installation

FROM base as production
# Only production files (21 essential files)
COPY --from=base /app /app
EXPOSE 8000
CMD ["uvicorn", "app:app", "--host", "0.0.0.0", "--port", "8000"]
```

### **ENVIRONMENT MANAGEMENT**
```yaml
# docker-compose.yml Structure
services:
  voice-agent:
    build: .
    environment:
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - LIVEKIT_API_KEY=${LIVEKIT_API_KEY}
    ports:
      - "8000:8000"
    depends_on:
      - redis
      - postgres
```

---

## 🧪 **TESTING REGELN**

### **TEST PYRAMID**
```python
# 1. UNIT TESTS (70%)
# Jede Funktion, jeder Service
pytest tests/unit/

# 2. INTEGRATION TESTS (20%)
# API Endpoints, Database, External Services
pytest tests/integration/

# 3. E2E TESTS (10%)
# Komplette Voice Agent Workflows
pytest tests/e2e/
```

### **VOICE TESTING**
```python
# AUDIO TESTING PIPELINE
# 1. Synthetic Audio Generation
# 2. STT Accuracy Testing
# 3. Response Quality Testing
# 4. TTS Quality Testing
# 5. End-to-End Latency Testing

# test_voice.py
def test_voice_pipeline_latency():
    start_time = time.time()
    # Complete voice interaction
    end_time = time.time()
    assert (end_time - start_time) < 0.5  # <500ms
```

---

## 📁 **PROJEKT STRUKTUR REGELN**

### **ESSENTIAL FILES (21 Production Files)**
```
🔴 CORE SERVICES (9 files)
├── app.py                          # FastAPI Main Application
├── routers/                        # API Route Handlers
├── services/websocket_service.py   # WebRTC & Real-time
├── services/audio_service.py       # STT/TTS Processing
├── services/llm_service.py         # AI Response Generation
├── services/ultra_low_latency_service.py  # Performance
└── services/webhook_service.py     # External Integrations

🔴 CONFIGURATION (4 files)
├── .env.example                    # Environment Template
├── config/agent_personalities.yaml # AI Agent Configs
├── prompts/prompts.yaml           # Conversation Templates
└── requirements.txt               # Python Dependencies

🔴 DEPLOYMENT (4 files)
├── docker-compose.yml             # Container Orchestration
├── Dockerfile                     # Container Definition
├── scripts/build_production.ps1   # Production Build
└── scripts/deploy.sh              # Deployment Automation

🔴 TESTING (4 files)
├── test_api.py                    # API Testing
├── test_voice.py                  # Voice Pipeline Testing
├── test_performance.py            # Performance Validation
└── pytest.ini                    # Test Configuration
```

### **ARCHIVIEREN (Unnötige Files)**
```
❌ REDUNDANT RULES
├── cline_rules.md                 # → Konsolidiert in .trae_rules.md
├── cursor_rules.mdc               # → Konsolidiert in .trae_rules.md
└── roo_rules.md                   # → Konsolidiert in .trae_rules.md

❌ EXPERIMENTAL
├── experimental/                  # → /archive/experimental/
├── prototypes/                    # → /archive/prototypes/
└── old_configs/                   # → /archive/old_configs/

❌ REDUNDANT DOCS
├── duplicate_readme_files/        # → Konsolidieren
├── outdated_documentation/        # → /archive/docs/
└── unused_templates/              # → /archive/templates/
```

---

## 🔧 **DEVELOPMENT WORKFLOW**

### **DAILY ROUTINE**
```bash
# 1. MORNING SETUP
task-master next                    # "Was ist die nächste Task?"
git pull origin main               # Latest changes
docker-compose up -d               # Start development environment

# 2. DEVELOPMENT
# - Implementiere Task/Subtask
# - Schreibe Tests
# - Dokumentiere Änderungen
# - Teste lokal

# 3. COMPLETION
task-master update-task [id] --status=done
git add . && git commit -m "Task [id]: [description]"
git push origin feature/task-[id]

# 4. NEXT ITERATION
# User: "Okay, hey, ist gut, weiter so"
# System: Automatically shows next task
```

### **FEATURE DEVELOPMENT**
```bash
# 1. TASK EXPANSION
task-master expand-task [epic-id]   # Break down into subtasks

# 2. BRANCH STRATEGY
git checkout -b feature/task-[id]

# 3. IMPLEMENTATION
# - Core functionality
# - Unit tests
# - Integration tests
# - Documentation

# 4. VALIDATION
pytest tests/                      # All tests pass
docker build .                     # Production build works
scripts/validate_production_files.py  # Only essential files
```

---

## 🚨 **CRITICAL SUCCESS FACTORS**

### **PERFORMANCE REQUIREMENTS**
```
✅ WebRTC Streaming: Real-time audio processing
✅ Ultra-Low-Latency: <100ms response time
✅ Whisper Integration: Local STT processing
✅ Hardware Acceleration: GPU/CPU optimization
✅ Scalability: Multi-tenant architecture
```

### **COMPETITIVE ADVANTAGES**
```
🎯 vs VAPI: 10x lower latency, open-source flexibility
🎯 vs Retell: Better audio quality, custom integrations
🎯 vs Artisan: Enterprise features, cost efficiency
🎯 vs Parloa: Technical superiority, faster development
```

### **QUALITY GATES**
```
🔍 Code Review: Alle Changes reviewed
🔍 Test Coverage: >80% für Core Services
🔍 Performance: Latency benchmarks erfüllt
🔍 Security: API Keys secured, Input validation
🔍 Documentation: README, API docs, deployment guides
```

---

## 🎯 **TASKMASTER INTEGRATION**

### **MCP TOOLS VERFÜGBAR**
```
🛠️ initialize-project     # Projekt Setup
🛠️ parse-prd             # Requirements → Tasks
🛠️ analyze-complexity    # Komplexitäts-Analyse
🛠️ expand-task           # Task → Subtasks
🛠️ next-task             # Nächste Task bestimmen
🛠️ update-task           # Status Updates
🛠️ add-subtask           # Neue Subtasks
🛠️ validate-dependencies # Dependency Check
```

### **WORKFLOW AUTOMATION**
```
1. PRD PARSING: Vollständiges Requirements Document
2. TASK HIERARCHY: Epic → Feature → Task → Subtask
3. DEPENDENCY MANAGEMENT: Automatische Reihenfolge
4. PROGRESS TRACKING: Status Updates ohne manuelle Planung
5. NEXT TASK LOGIC: "Was kommt als nächstes?"
```

---

## 💡 **BEST PRACTICES**

### **CODE ORGANIZATION**
- **Single Responsibility:** Jede Datei hat einen klaren Zweck
- **Dependency Injection:** Services über FastAPI DI System
- **Configuration Management:** Environment-based configs
- **Error Handling:** Structured logging und proper exceptions

### **PERFORMANCE OPTIMIZATION**
- **Async Programming:** Alle I/O Operations asynchron
- **Connection Pooling:** Für External APIs
- **Caching Strategy:** Redis für häufige Requests
- **Monitoring:** Structured logs, metrics, tracing

### **DEPLOYMENT STRATEGY**
- **Multi-stage Builds:** Optimierte Docker Images
- **Environment Separation:** Dev, Staging, Production
- **Health Checks:** Automated monitoring
- **Rollback Strategy:** Blue-green deployments

---

## 🏆 **ERFOLGS-METRIKEN**

### **TECHNISCHE METRIKEN**
```
📊 Response Time: <100ms average
📊 Uptime: >99.9%
📊 Test Coverage: >80%
📊 Build Time: <5 minutes
📊 Deployment Time: <2 minutes
```

### **BUSINESS METRIKEN**
```
💰 Cost Reduction: 90% vs Commercial Solutions
💰 Development Speed: 10x faster iteration
💰 Feature Completeness: 100% VAPI feature parity
💰 Market Position: #1 Open-Source Voice Agent Platform
```

---

**FAZIT:** Diese konsolidierten Regeln ersetzen alle separaten Regel-Dateien und optimieren den Workflow für Taskmaster-basierte Entwicklung. Ziel: "Okay, hey, ist gut, weiter so" mit minimaler manueller Planung.
