---
description: Konsolidierte Regeln fÃ¼r VAPI-Homemade Projekt - Trae AI Optimiert
globs: **/*
alwaysApply: true
---

# ğŸ¯ TRAE AI RULES - VAPI-HOMEMADE PROJECT
## Konsolidierte Regeln fÃ¼r Voice Agent Platform Development

**Version:** 3.0 (Konsolidiert aus cline_rules.md, cursor_rules.mdc, roo_rules.md)  
**Ziel:** VAPI/Retell/Artisan/Parloa Ã¼berholen mit 10x besserer Performance  
**Workflow:** Taskmaster-basiert mit "weiter so" Automation  

---

## ğŸš€ **PROJEKT-VISION & ZIELE**

### **HAUPTZIEL**
```
ğŸ¯ VAPI-Homemade soll VAPI, Retell, Artisan.co und Parloa Ã¼berholen
ğŸ¯ 10x bessere Performance bei 90% niedrigeren Kosten
ğŸ¯ Ultra-Low-Latency (<100ms) Voice Agent Platform
ğŸ¯ Enterprise-Grade Features mit Open-Source FlexibilitÃ¤t
```

### **TECHNISCHE ZIELE**
- **WebRTC Streaming:** Echte Real-time Audio Processing
- **Whisper Integration:** Lokale STT mit Hardware-Acceleration
- **Ultra-Low-Latency:** <100ms End-to-End Response Time
- **Enterprise Features:** SIP, Multi-tenant, Analytics
- **Production Ready:** Docker, Monitoring, Scaling

---

## ğŸ“‹ **TASKMASTER WORKFLOW REGELN**

### **WORKFLOW PRINZIP**
```
1. MASTERPLAN ERSTELLEN: VollstÃ¤ndiges PRD â†’ parse-prd â†’ Task-Hierarchie
2. NEXT TASK ABFRAGEN: "Was ist die nÃ¤chste Task?"
3. TASK BEARBEITEN: Code implementieren, testen, dokumentieren
4. STATUS UPDATE: "Task X completed" â†’ Automatisch nÃ¤chste Task
5. BESTÃ„TIGUNG: "Okay, hey, ist gut, weiter so" â†’ Workflow continues
```

### **TASKMASTER COMMANDS**
```bash
# Daily Workflow
task-master next                    # NÃ¤chste Task anzeigen
task-master show [id]              # Task Details anzeigen
task-master update-task [id]       # Task Status aktualisieren
task-master add-subtask [id]       # Subtask hinzufÃ¼gen

# Planning & Analysis
task-master list --status pending  # Offene Tasks anzeigen
task-master analyze-complexity     # KomplexitÃ¤t bewerten
task-master expand-task [id]       # Task in Subtasks aufteilen
```

---

## ğŸ—ï¸ **CODE DEVELOPMENT REGELN**

### **ARCHITEKTUR PRINZIPIEN**
```python
# 1. MICROSERVICES ARCHITECTURE
# Jeder Service hat klare Verantwortlichkeit:
# - websocket_service.py: WebRTC & Real-time Communication
# - audio_service.py: STT/TTS Processing
# - llm_service.py: AI Response Generation
# - ultra_low_latency_service.py: Performance Optimization

# 2. DEPENDENCY INJECTION
# Alle Services Ã¼ber FastAPI Dependency System
# Testbar, mockbar, austauschbar

# 3. ASYNC/AWAIT EVERYWHERE
# Alle I/O Operations asynchron
# WebSocket, HTTP, Database, AI APIs
```

### **PERFORMANCE REGELN**
```python
# ULTRA-LOW-LATENCY REQUIREMENTS
# - WebSocket Response: <50ms
# - STT Processing: <100ms
# - LLM Response: <200ms
# - TTS Generation: <150ms
# - Total End-to-End: <500ms

# OPTIMIZATION STRATEGIES
# 1. Connection Pooling fÃ¼r alle External APIs
# 2. Caching fÃ¼r hÃ¤ufige Requests
# 3. Streaming fÃ¼r Audio Processing
# 4. Hardware Acceleration wo mÃ¶glich
```

### **CODE QUALITY STANDARDS**
```python
# 1. TYPE HINTS ÃœBERALL
from typing import Dict, List, Optional, Union

def process_audio(audio_data: bytes, config: Dict[str, Any]) -> AudioResponse:
    """Process audio with type safety"""
    pass

# 2. ERROR HANDLING
try:
    result = await external_api_call()
except APIException as e:
    logger.error(f"API call failed: {e}")
    raise ServiceException(f"Processing failed: {e}")

# 3. LOGGING & MONITORING
import structlog
logger = structlog.get_logger()

@router.post("/webhook")
async def webhook_handler(request: WebhookRequest):
    logger.info("webhook_received", request_id=request.id)
    # Process...
    logger.info("webhook_processed", duration_ms=duration)
```

---

## ğŸ³ **DOCKER & DEPLOYMENT REGELN**

### **PRODUCTION SETUP**
```dockerfile
# MULTI-STAGE BUILDS fÃ¼r Optimization
FROM python:3.11-slim as base
# Dependencies installation

FROM base as production
# Only production files (21 essential files)
COPY --from=base /app /app
EXPOSE 8000
CMD ["uvicorn", "app:app", "--host", "0.0.0.0", "--port", "8000"]
```

### **ENVIRONMENT MANAGEMENT**
```yaml
# docker-compose.yml Structure
services:
  voice-agent:
    build: .
    environment:
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - LIVEKIT_API_KEY=${LIVEKIT_API_KEY}
    ports:
      - "8000:8000"
    depends_on:
      - redis
      - postgres
```

---

## ğŸ§ª **TESTING REGELN**

### **TEST PYRAMID**
```python
# 1. UNIT TESTS (70%)
# Jede Funktion, jeder Service
pytest tests/unit/

# 2. INTEGRATION TESTS (20%)
# API Endpoints, Database, External Services
pytest tests/integration/

# 3. E2E TESTS (10%)
# Komplette Voice Agent Workflows
pytest tests/e2e/
```

### **VOICE TESTING**
```python
# AUDIO TESTING PIPELINE
# 1. Synthetic Audio Generation
# 2. STT Accuracy Testing
# 3. Response Quality Testing
# 4. TTS Quality Testing
# 5. End-to-End Latency Testing

# test_voice.py
def test_voice_pipeline_latency():
    start_time = time.time()
    # Complete voice interaction
    end_time = time.time()
    assert (end_time - start_time) < 0.5  # <500ms
```

---

## ğŸ“ **PROJEKT STRUKTUR REGELN**

### **ESSENTIAL FILES (21 Production Files)**
```
ğŸ”´ CORE SERVICES (9 files)
â”œâ”€â”€ app.py                          # FastAPI Main Application
â”œâ”€â”€ routers/                        # API Route Handlers
â”œâ”€â”€ services/websocket_service.py   # WebRTC & Real-time
â”œâ”€â”€ services/audio_service.py       # STT/TTS Processing
â”œâ”€â”€ services/llm_service.py         # AI Response Generation
â”œâ”€â”€ services/ultra_low_latency_service.py  # Performance
â””â”€â”€ services/webhook_service.py     # External Integrations

ğŸ”´ CONFIGURATION (4 files)
â”œâ”€â”€ .env.example                    # Environment Template
â”œâ”€â”€ config/agent_personalities.yaml # AI Agent Configs
â”œâ”€â”€ prompts/prompts.yaml           # Conversation Templates
â””â”€â”€ requirements.txt               # Python Dependencies

ğŸ”´ DEPLOYMENT (4 files)
â”œâ”€â”€ docker-compose.yml             # Container Orchestration
â”œâ”€â”€ Dockerfile                     # Container Definition
â”œâ”€â”€ scripts/build_production.ps1   # Production Build
â””â”€â”€ scripts/deploy.sh              # Deployment Automation

ğŸ”´ TESTING (4 files)
â”œâ”€â”€ test_api.py                    # API Testing
â”œâ”€â”€ test_voice.py                  # Voice Pipeline Testing
â”œâ”€â”€ test_performance.py            # Performance Validation
â””â”€â”€ pytest.ini                    # Test Configuration
```

### **ARCHIVIEREN (UnnÃ¶tige Files)**
```
âŒ REDUNDANT RULES
â”œâ”€â”€ cline_rules.md                 # â†’ Konsolidiert in .trae_rules.md
â”œâ”€â”€ cursor_rules.mdc               # â†’ Konsolidiert in .trae_rules.md
â””â”€â”€ roo_rules.md                   # â†’ Konsolidiert in .trae_rules.md

âŒ EXPERIMENTAL
â”œâ”€â”€ experimental/                  # â†’ /archive/experimental/
â”œâ”€â”€ prototypes/                    # â†’ /archive/prototypes/
â””â”€â”€ old_configs/                   # â†’ /archive/old_configs/

âŒ REDUNDANT DOCS
â”œâ”€â”€ duplicate_readme_files/        # â†’ Konsolidieren
â”œâ”€â”€ outdated_documentation/        # â†’ /archive/docs/
â””â”€â”€ unused_templates/              # â†’ /archive/templates/
```

---

## ğŸ”§ **DEVELOPMENT WORKFLOW**

### **DAILY ROUTINE**
```bash
# 1. MORNING SETUP
task-master next                    # "Was ist die nÃ¤chste Task?"
git pull origin main               # Latest changes
docker-compose up -d               # Start development environment

# 2. DEVELOPMENT
# - Implementiere Task/Subtask
# - Schreibe Tests
# - Dokumentiere Ã„nderungen
# - Teste lokal

# 3. COMPLETION
task-master update-task [id] --status=done
git add . && git commit -m "Task [id]: [description]"
git push origin feature/task-[id]

# 4. NEXT ITERATION
# User: "Okay, hey, ist gut, weiter so"
# System: Automatically shows next task
```

### **FEATURE DEVELOPMENT**
```bash
# 1. TASK EXPANSION
task-master expand-task [epic-id]   # Break down into subtasks

# 2. BRANCH STRATEGY
git checkout -b feature/task-[id]

# 3. IMPLEMENTATION
# - Core functionality
# - Unit tests
# - Integration tests
# - Documentation

# 4. VALIDATION
pytest tests/                      # All tests pass
docker build .                     # Production build works
scripts/validate_production_files.py  # Only essential files
```

---

## ğŸš¨ **CRITICAL SUCCESS FACTORS**

### **PERFORMANCE REQUIREMENTS**
```
âœ… WebRTC Streaming: Real-time audio processing
âœ… Ultra-Low-Latency: <100ms response time
âœ… Whisper Integration: Local STT processing
âœ… Hardware Acceleration: GPU/CPU optimization
âœ… Scalability: Multi-tenant architecture
```

### **COMPETITIVE ADVANTAGES**
```
ğŸ¯ vs VAPI: 10x lower latency, open-source flexibility
ğŸ¯ vs Retell: Better audio quality, custom integrations
ğŸ¯ vs Artisan: Enterprise features, cost efficiency
ğŸ¯ vs Parloa: Technical superiority, faster development
```

### **QUALITY GATES**
```
ğŸ” Code Review: Alle Changes reviewed
ğŸ” Test Coverage: >80% fÃ¼r Core Services
ğŸ” Performance: Latency benchmarks erfÃ¼llt
ğŸ” Security: API Keys secured, Input validation
ğŸ” Documentation: README, API docs, deployment guides
```

---

## ğŸ¯ **TASKMASTER INTEGRATION**

### **MCP TOOLS VERFÃœGBAR**
```
ğŸ› ï¸ initialize-project     # Projekt Setup
ğŸ› ï¸ parse-prd             # Requirements â†’ Tasks
ğŸ› ï¸ analyze-complexity    # KomplexitÃ¤ts-Analyse
ğŸ› ï¸ expand-task           # Task â†’ Subtasks
ğŸ› ï¸ next-task             # NÃ¤chste Task bestimmen
ğŸ› ï¸ update-task           # Status Updates
ğŸ› ï¸ add-subtask           # Neue Subtasks
ğŸ› ï¸ validate-dependencies # Dependency Check
```

### **WORKFLOW AUTOMATION**
```
1. PRD PARSING: VollstÃ¤ndiges Requirements Document
2. TASK HIERARCHY: Epic â†’ Feature â†’ Task â†’ Subtask
3. DEPENDENCY MANAGEMENT: Automatische Reihenfolge
4. PROGRESS TRACKING: Status Updates ohne manuelle Planung
5. NEXT TASK LOGIC: "Was kommt als nÃ¤chstes?"
```

---

## ğŸ’¡ **BEST PRACTICES**

### **CODE ORGANIZATION**
- **Single Responsibility:** Jede Datei hat einen klaren Zweck
- **Dependency Injection:** Services Ã¼ber FastAPI DI System
- **Configuration Management:** Environment-based configs
- **Error Handling:** Structured logging und proper exceptions

### **PERFORMANCE OPTIMIZATION**
- **Async Programming:** Alle I/O Operations asynchron
- **Connection Pooling:** FÃ¼r External APIs
- **Caching Strategy:** Redis fÃ¼r hÃ¤ufige Requests
- **Monitoring:** Structured logs, metrics, tracing

### **DEPLOYMENT STRATEGY**
- **Multi-stage Builds:** Optimierte Docker Images
- **Environment Separation:** Dev, Staging, Production
- **Health Checks:** Automated monitoring
- **Rollback Strategy:** Blue-green deployments

---

## ğŸ† **ERFOLGS-METRIKEN**

### **TECHNISCHE METRIKEN**
```
ğŸ“Š Response Time: <100ms average
ğŸ“Š Uptime: >99.9%
ğŸ“Š Test Coverage: >80%
ğŸ“Š Build Time: <5 minutes
ğŸ“Š Deployment Time: <2 minutes
```

### **BUSINESS METRIKEN**
```
ğŸ’° Cost Reduction: 90% vs Commercial Solutions
ğŸ’° Development Speed: 10x faster iteration
ğŸ’° Feature Completeness: 100% VAPI feature parity
ğŸ’° Market Position: #1 Open-Source Voice Agent Platform
```

---

**FAZIT:** Diese konsolidierten Regeln ersetzen alle separaten Regel-Dateien und optimieren den Workflow fÃ¼r Taskmaster-basierte Entwicklung. Ziel: "Okay, hey, ist gut, weiter so" mit minimaler manueller Planung.
